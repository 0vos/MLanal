#!/usr/bin/env python3
"""Compare SHARP-projected depth maps against DepthPro depth maps.

Assumptions / inputs:
- SHARP depth maps were generated by tools/sharp_ply_depthmaps.py and live at:
    images/sharp_depthmaps/<IMG_xxxx>/depth_raw.npy
- DepthPro outputs are in per-image folders like:
    /Users/rufuslee/Documents/GitHub/backend/recon_depthpro_raw_ply/<IMG_xxxx>/depth.npy

This script:
- aligns depth scales on the overlap mask (SHARP is sparse; DepthPro is dense)
- computes error metrics per scene (raw and aligned)
- writes plots: depth visualizations, error heatmaps, scatter plots, histograms
- writes a markdown report with your scene descriptions

Run:
  /Users/rufuslee/Documents/GitHub/MLanal/mlanalenv/bin/python tools/compare_sharp_vs_depthpro.py \
    --sharp-root images/sharp_depthmaps \
    --depthpro-root /Users/rufuslee/Documents/GitHub/backend/recon_depthpro_raw_ply \
    --outdir images/sharp_vs_depthpro/analysis
"""

from __future__ import annotations

import argparse
import json
import math
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Dict, Optional, Tuple

import matplotlib

matplotlib.use("Agg")

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from PIL import Image


SCENE_DESCRIPTIONS: Dict[str, str] = {
    "IMG_9546": "复杂工作间环境：物体比较零碎且不常见，而且能看到远处的房子",
    "IMG_9568": "卧室角落：较封闭，有高低物体堆叠而且有多种光线",
    "IMG_9569": "桌子椅子工位：简单图",
    "IMG_9579": "走廊：漫长笔直的地面",
    "IMG_9581": "玻璃罩子内的轮船模型：玻璃反光",
    "IMG_9582": "黑色电梯间视图：偏昏暗（手机自动调亮后仍暗）",
}


@dataclass
class Metrics:
    stem: str
    overlap_pixels: int
    overlap_ratio: float

    # Raw error
    mae_raw: float
    rmse_raw: float
    absrel_raw: float

    # Scale-only aligned
    scale_median: float
    mae_scale: float
    rmse_scale: float
    absrel_scale: float

    # Scale+shift aligned
    scale_ls: float
    shift_ls: float
    mae_affine: float
    rmse_affine: float
    absrel_affine: float

    # Ranges
    sharp_p50: float
    depthpro_p50: float


def _save_fig(path: Path) -> None:
    plt.tight_layout()
    plt.savefig(path, dpi=200)
    plt.close()


def _depth_vis(depth: np.ndarray, mask: np.ndarray, out_path: Path) -> Tuple[float, float]:
    valid = depth[mask]
    if valid.size == 0:
        Image.fromarray(np.zeros(depth.shape, dtype=np.uint8)).save(out_path)
        return 0.0, 0.0

    lo = float(np.percentile(valid, 1))
    hi = float(np.percentile(valid, 99))
    if hi <= lo:
        lo = float(valid.min())
        hi = float(valid.max())
        if hi <= lo:
            hi = lo + 1.0

    norm = (depth.astype(np.float32) - lo) / (hi - lo)
    norm[~mask] = 0.0
    norm = np.clip(norm, 0.0, 1.0)

    cmap = plt.get_cmap("viridis")
    rgb = (cmap(norm)[..., :3] * 255.0).astype(np.uint8)
    Image.fromarray(rgb).save(out_path)
    return lo, hi


def _error_vis(err: np.ndarray, mask: np.ndarray, out_path: Path) -> None:
    valid = err[mask]
    if valid.size == 0:
        Image.fromarray(np.zeros(err.shape, dtype=np.uint8)).save(out_path)
        return

    hi = float(np.percentile(valid, 99))
    if hi <= 0:
        hi = float(valid.max())
        if hi <= 0:
            hi = 1.0

    norm = err.astype(np.float32) / hi
    norm[~mask] = 0.0
    norm = np.clip(norm, 0.0, 1.0)

    cmap = plt.get_cmap("magma")
    rgb = (cmap(norm)[..., :3] * 255.0).astype(np.uint8)
    Image.fromarray(rgb).save(out_path)


def _median_scale(a: np.ndarray, b: np.ndarray) -> float:
    # scale so that median(a*scale) ~= median(b)
    ma = float(np.median(a))
    mb = float(np.median(b))
    if ma <= 0:
        return 1.0
    return mb / ma


def _ls_scale_shift(a: np.ndarray, b: np.ndarray) -> Tuple[float, float]:
    # minimize ||s*a + t - b||^2
    A = np.stack([a, np.ones_like(a)], axis=1).astype(np.float64)
    y = b.astype(np.float64)
    sol, *_ = np.linalg.lstsq(A, y, rcond=None)
    s = float(sol[0])
    t = float(sol[1])
    return s, t


def _metrics(pred: np.ndarray, gt: np.ndarray, mask: np.ndarray) -> Tuple[float, float, float]:
    p = pred[mask].astype(np.float64)
    g = gt[mask].astype(np.float64)
    if p.size == 0:
        return float("nan"), float("nan"), float("nan")
    err = np.abs(p - g)
    mae = float(err.mean())
    rmse = float(np.sqrt(((p - g) ** 2).mean()))
    absrel = float((err / np.clip(g, 1e-6, None)).mean())
    return mae, rmse, absrel


def compare_one(stem: str, sharp_root: Path, depthpro_root: Path, outdir: Path) -> Optional[Metrics]:
    sharp_path = sharp_root / stem / "depth_raw.npy"
    depthpro_path = depthpro_root / stem / "depth.npy"

    if not sharp_path.exists() or not depthpro_path.exists():
        return None

    sharp = np.load(sharp_path).astype(np.float32)
    depthpro = np.load(depthpro_path).astype(np.float32)

    if sharp.shape != depthpro.shape:
        # Shouldn't happen here, but be safe.
        h = min(sharp.shape[0], depthpro.shape[0])
        w = min(sharp.shape[1], depthpro.shape[1])
        sharp = sharp[:h, :w]
        depthpro = depthpro[:h, :w]

    sharp_mask = sharp > 0
    depthpro_mask = np.isfinite(depthpro) & (depthpro > 0)
    overlap = sharp_mask & depthpro_mask

    overlap_pixels = int(overlap.sum())
    overlap_ratio = float(overlap_pixels / overlap.size)

    if overlap_pixels < 1000:
        # Too little overlap to compare reliably.
        return None

    # Compute alignments on overlap
    a = sharp[overlap]
    b = depthpro[overlap]

    scale_med = _median_scale(a, b)

    s_ls, t_ls = _ls_scale_shift(a, b)

    # Evaluate
    mae_raw, rmse_raw, absrel_raw = _metrics(sharp, depthpro, overlap)

    sharp_scale = sharp * scale_med
    mae_s, rmse_s, absrel_s = _metrics(sharp_scale, depthpro, overlap)

    sharp_affine = sharp * s_ls + t_ls
    mae_a, rmse_a, absrel_a = _metrics(sharp_affine, depthpro, overlap)

    # Visual outputs
    scene_out = outdir / stem
    scene_out.mkdir(parents=True, exist_ok=True)

    # depth visualizations
    _depth_vis(sharp, sharp_mask, scene_out / "sharp_depth.png")
    _depth_vis(depthpro, depthpro_mask, scene_out / "depthpro_depth.png")
    _depth_vis(sharp_scale, sharp_mask, scene_out / "sharp_depth_scale.png")

    # error maps on overlap
    err_raw = np.abs(sharp - depthpro)
    err_scale = np.abs(sharp_scale - depthpro)
    err_affine = np.abs(sharp_affine - depthpro)
    _error_vis(err_raw, overlap, scene_out / "err_raw.png")
    _error_vis(err_scale, overlap, scene_out / "err_scale.png")
    _error_vis(err_affine, overlap, scene_out / "err_affine.png")

    # Error histograms
    for name, err in [("raw", err_raw), ("scale", err_scale), ("affine", err_affine)]:
        vals = err[overlap]
        plt.figure(figsize=(7, 4))
        plt.hist(vals, bins=80)
        plt.title(f"|error| histogram ({name}) - {stem}")
        plt.xlabel("abs error")
        plt.ylabel("count")
        _save_fig(scene_out / f"hist_err_{name}.png")

    # Scatter: sharp vs depthpro on overlap (sample for speed)
    idx = np.random.default_rng(0).choice(a.shape[0], size=min(200_000, a.shape[0]), replace=False)
    aa = a[idx]
    bb = b[idx]

    plt.figure(figsize=(6, 6))
    sns.scatterplot(x=aa, y=bb, s=2)
    xline = np.linspace(float(np.percentile(aa, 1)), float(np.percentile(aa, 99)), 200)
    plt.plot(xline, xline * scale_med, color="orange", label=f"median scale={scale_med:.3f}")
    plt.plot(xline, xline * s_ls + t_ls, color="red", label=f"ls s={s_ls:.3f}, t={t_ls:.3f}")
    plt.xlabel("SHARP depth")
    plt.ylabel("DepthPro depth")
    plt.title(f"Scatter on overlap - {stem}")
    plt.legend()
    _save_fig(scene_out / "scatter_overlap.png")

    # Save per-scene json
    (scene_out / "metrics.json").write_text(
        json.dumps(
            {
                "stem": stem,
                "overlap_pixels": overlap_pixels,
                "overlap_ratio": overlap_ratio,
                "mae_raw": mae_raw,
                "rmse_raw": rmse_raw,
                "absrel_raw": absrel_raw,
                "scale_median": scale_med,
                "mae_scale": mae_s,
                "rmse_scale": rmse_s,
                "absrel_scale": absrel_s,
                "scale_ls": s_ls,
                "shift_ls": t_ls,
                "mae_affine": mae_a,
                "rmse_affine": rmse_a,
                "absrel_affine": absrel_a,
            },
            ensure_ascii=False,
            indent=2,
        )
        + "\n",
        encoding="utf-8",
    )

    sharp_p50 = float(np.median(a))
    depthpro_p50 = float(np.median(b))

    return Metrics(
        stem=stem,
        overlap_pixels=overlap_pixels,
        overlap_ratio=overlap_ratio,
        mae_raw=mae_raw,
        rmse_raw=rmse_raw,
        absrel_raw=absrel_raw,
        scale_median=scale_med,
        mae_scale=mae_s,
        rmse_scale=rmse_s,
        absrel_scale=absrel_s,
        scale_ls=s_ls,
        shift_ls=t_ls,
        mae_affine=mae_a,
        rmse_affine=rmse_a,
        absrel_affine=absrel_a,
        sharp_p50=sharp_p50,
        depthpro_p50=depthpro_p50,
    )


def main() -> int:
    ap = argparse.ArgumentParser(description="Compare SHARP depthmaps vs DepthPro depth maps.")
    ap.add_argument("--sharp-root", type=str, default="images/sharp_depthmaps", help="SHARP depthmaps root")
    ap.add_argument(
        "--sharp-summary",
        type=str,
        default="images/sharp_depthmaps/sharp_ply_depthmaps_summary.csv",
        help="Optional SHARP summary CSV (for camera_source, etc.)",
    )
    ap.add_argument(
        "--depthpro-root",
        type=str,
        required=True,
        help="DepthPro output root (contains per-image folders with depth.npy)",
    )
    ap.add_argument("--outdir", type=str, default="images/sharp_vs_depthpro/analysis", help="Output directory")
    ap.add_argument("--stems", type=str, default="", help="Comma-separated stems to run (default: infer from sharp-root)")
    ap.add_argument(
        "--image-metrics",
        type=str,
        default="images/image_metrics_report.csv",
        help="Optional image metrics CSV (for brightness/contrast/noise correlations)",
    )
    args = ap.parse_args()

    sharp_root = Path(args.sharp_root)
    depthpro_root = Path(args.depthpro_root)
    outdir = Path(args.outdir)
    outdir.mkdir(parents=True, exist_ok=True)

    if args.stems.strip():
        stems = [s.strip() for s in args.stems.split(",") if s.strip()]
    else:
        stems = sorted([p.name for p in sharp_root.iterdir() if p.is_dir() and p.name.startswith("IMG_")])

    rows = []
    for stem in stems:
        print(stem)
        m = compare_one(stem, sharp_root=sharp_root, depthpro_root=depthpro_root, outdir=outdir)
        if m is None:
            continue
        row = asdict(m)
        row["scene"] = SCENE_DESCRIPTIONS.get(stem, "")
        rows.append(row)

    if not rows:
        raise SystemExit("No comparable stems found.")

    df = pd.DataFrame(rows)

    # Optional join with SHARP camera_source
    sharp_summary = Path(args.sharp_summary)
    if sharp_summary.exists():
        ssum = pd.read_csv(sharp_summary)
        ssum["stem"] = ssum["ply_path"].map(lambda p: Path(str(p)).stem)
        keep = [c for c in ["stem", "camera_source"] if c in ssum.columns]
        if keep:
            df = df.merge(ssum[keep], on="stem", how="left")

    # Optional join with image metrics
    image_metrics = Path(args.image_metrics)
    if image_metrics.exists():
        m = pd.read_csv(image_metrics)
        m["stem"] = m["filename"].map(lambda x: Path(str(x)).stem)
        keep = [
            c
            for c in [
                "stem",
                "brightness_mean",
                "contrast_std",
                "sharpness_laplacian_var",
                "noise_sigma_est",
            ]
            if c in m.columns
        ]
        if keep:
            df = df.merge(m[keep], on="stem", how="left")

    df.to_csv(outdir / "sharp_vs_depthpro_metrics.csv", index=False, encoding="utf-8")

    # Summary plots
    plt.figure(figsize=(10, 4.8))
    sns.barplot(data=df.sort_values("mae_scale"), x="stem", y="mae_scale")
    plt.xticks(rotation=30, ha="right")
    plt.title("MAE after median-scale alignment (on overlap)")
    _save_fig(outdir / "bar_mae_scale.png")

    plt.figure(figsize=(10, 4.8))
    sns.barplot(data=df.sort_values("absrel_scale"), x="stem", y="absrel_scale")
    plt.xticks(rotation=30, ha="right")
    plt.title("AbsRel after median-scale alignment (on overlap)")
    _save_fig(outdir / "bar_absrel_scale.png")

    plt.figure(figsize=(10, 4.8))
    sns.barplot(data=df.sort_values("overlap_ratio"), x="stem", y="overlap_ratio")
    plt.xticks(rotation=30, ha="right")
    plt.title("Overlap ratio (SHARP sparse mask ∩ DepthPro valid)")
    _save_fig(outdir / "bar_overlap_ratio.png")

    # Correlate photo brightness/noise with error (optional)
    if "brightness_mean" in df.columns:
        plt.figure(figsize=(6.8, 4.8))
        sns.scatterplot(data=df, x="brightness_mean", y="absrel_scale", hue="stem", s=60)
        sns.regplot(data=df, x="brightness_mean", y="absrel_scale", scatter=False, color="orange")
        plt.title("brightness_mean vs AbsRel (scale-aligned)")
        _save_fig(outdir / "scatter_brightness_vs_absrel.png")

    if "noise_sigma_est" in df.columns:
        plt.figure(figsize=(6.8, 4.8))
        sns.scatterplot(data=df, x="noise_sigma_est", y="absrel_scale", hue="stem", s=60)
        sns.regplot(data=df, x="noise_sigma_est", y="absrel_scale", scatter=False, color="orange")
        plt.title("noise_sigma_est vs AbsRel (scale-aligned)")
        _save_fig(outdir / "scatter_noise_vs_absrel.png")

    # Report
    report = outdir / "sharp_vs_depthpro_report.md"
    table_cols = [
        "stem",
        "scene",
        "camera_source",
        "overlap_ratio",
        "scale_median",
        "mae_scale",
        "rmse_scale",
        "absrel_scale",
        "mae_affine",
        "absrel_affine",
    ]
    t = df[[c for c in table_cols if c in df.columns]].copy()
    for c in ["overlap_ratio", "scale_median", "mae_scale", "rmse_scale", "absrel_scale", "mae_affine", "absrel_affine"]:
        if c in t.columns:
            t[c] = pd.to_numeric(t[c], errors="coerce").map(lambda x: "" if pd.isna(x) else f"{x:.4f}")

    md = []
    md.append("# SHARP vs DepthPro 对比分析")
    md.append("")
    md.append("说明：SHARP 深度来自点云稀疏投影（z-buffer），DepthPro 深度为稠密预测；对比仅在 overlap mask 上计算。")
    md.append("")
    md.append("## 汇总表（overlap 上的误差）")
    md.append("")
    md.append(t.to_markdown(index=False))
    md.append("")
    md.append("## 总览图")
    md.append("")
    md.append("- MAE（scale 对齐后）：![](bar_mae_scale.png)")
    md.append("- AbsRel（scale 对齐后）：![](bar_absrel_scale.png)")
    md.append("- overlap_ratio：![](bar_overlap_ratio.png)")
    if (outdir / "scatter_brightness_vs_absrel.png").exists():
        md.append("- 亮度 vs AbsRel：![](scatter_brightness_vs_absrel.png)")
    if (outdir / "scatter_noise_vs_absrel.png").exists():
        md.append("- 噪声估计 vs AbsRel：![](scatter_noise_vs_absrel.png)")
    md.append("")
    md.append("## 分场景图")
    md.append("")
    md.append("每个场景目录包含：")
    md.append("- sharp_depth.png / depthpro_depth.png / sharp_depth_scale.png")
    md.append("- err_raw.png / err_scale.png / err_affine.png")
    md.append("- hist_err_*.png / scatter_overlap.png")
    md.append("")
    for stem in df["stem"].tolist():
        md.append(f"### {stem}")
        desc = SCENE_DESCRIPTIONS.get(stem, "")
        if desc:
            md.append(f"- 场景：{desc}")
        md.append(f"- 目录：`{stem}/`")
        md.append(f"  - ![]({stem}/sharp_depth.png)")
        md.append(f"  - ![]({stem}/depthpro_depth.png)")
        md.append(f"  - ![]({stem}/sharp_depth_scale.png)")
        md.append(f"  - ![]({stem}/err_scale.png)")
        md.append(f"  - ![]({stem}/scatter_overlap.png)")
        md.append("")

    report.write_text("\n".join(md) + "\n", encoding="utf-8")
    print(f"Wrote report: {report}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
